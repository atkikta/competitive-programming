{
	// Place your cpp workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	// for loop
	"for loop int": {
		"prefix": "fori",
		"body": [
		  "for(int ${1:i}=0; $1<$2; $1++){",
		  "    $0",
		  "}"
		],
		"description": "for loop int"
	},
	// sort
	"sort vector": {
		"prefix": "sort",
		"body": [
		  "std::sort($1.begin(), $1.end());$0"
		],
		"description": "sort vector"
	},
	// lis
	"longest increasing subsequence": {
		"prefix": "lis",
		"body": [
		  "int lis(const std::vector<int>& a){",
		  "    int n = a.size();",
		  "    std::vector<int> dp(n, INF);",
		  "    for(int i=0; i<n; i++){",
		  "        int pos = std::lower_bound(dp.begin(), dp.end(), a[i]) - dp.begin();",
		  "        dp[pos] = a[i];",
		  "    }",
		  "    return std::lower_bound(dp.begin(), dp.end(), INF) - dp.begin();",
		  "}"
		],
		"description": "longest increasing subsequence"
	  },
	//digit sum
	"sum of digits": {
		"prefix": "digit_sum",
		"body": [
		  "int digit_sum(int x) {",
		  "    int ans = 0;",
		  "    while (x > 0) {",
		  "        ans += x % 10;",
		  "        x /= 10;",
		  "    }",
		  "    return ans;",
		  "}"
		],
		"description": "sum of digits"
	  },
	//list of digits
	"list of digits": {
		"prefix": "digit_list",
		"body": [
		  "std::vector<int> digit_list(int x){",
		  "    std::vector<int> ans;",
		  "    while(x>0){",
		  "        ans.push_back(x%10);",
		  "        x /= 10;",
		  "    }",
		  "    std::reverse(ans.begin(), ans.end());",
		  "    return ans;",
		  "}"
		],
		"description": "list of digits"
	  },
	// inchworm
	"inchworm": {
		"prefix": "inchworm",
		"body": [
		  "int ans = 0;",
		  "int r = 0;",
		  "for(int l=0; l<n; l++){",
		  "    while(r<n){",
		  "        if(${1:terminate condition}) break;",
		  "        ${2:step right}",
		  "        r++;",
		  "    }",
		  "    //update ans",
		  "    ans = max(ans, r-l);",
		  "    ${3:step left}",
		  "}"
		],
		"description": "inchworm"
	  },
	// union find
	"unionfind": {
		"prefix": "unionfind",
		"body": [
		  "struct UnionFind {",
		  "  std::vector<int> d;",
		  "  UnionFind(int n=0): d(n,-1) {}",
		  "  int find(int x) {",
		  "    if (d[x] < 0) return x;",
		  "    return d[x] = find(d[x]);",
		  "  }",
		  "  bool unite(int x, int y) {",
		  "    x = find(x); y = find(y);",
		  "    if (x == y) return false;",
		  "    if (d[x] > d[y]) std::swap(x,y);",
		  "    d[x] += d[y];",
		  "    d[y] = x;",
		  "    return true;",
		  "  }",
		  "  bool same(int x, int y) { return find(x) == find(y);}",
		  "  int size(int x) { return -d[find(x)];}",
		  "};"
		],
		"description": "unionfind"
	  },
	  "graph": {
		"prefix": "graph",
		"body": [
		  "struct DiGraph{",
		  "    int num_node;",
		  "    std::vector<std::vector<Edge>> edges;",
		  "    std::vector<std::vector<Edge>> reverse_edges;",
		  "    DiGraph(int size){",
		  "        num_node = size;",
		  "        edges = std::vector<std::vector<Edge>>(size);",
		  "        reverse_edges = std::vector<std::vector<Edge>>(size);",
		  "    }",
		  "    void addEdge(int from, int to, int cost){",
		  "        edges.at(from).push_back(Edge(from, to, cost));",
		  "        reverse_edges.at(to).push_back(Edge(to, from, cost));",
		  "    }",
		  "    std::vector<long long> dijkstra(int start_node){",
		  "        std::vector<long long> distance(num_node, LONG_LONG_MAX/2);",
		  "        std::priority_queue<std::pair<long long, int>, std::vector<std::pair<long long, int>>, std::greater<std::pair<long long, int>>> que;",
		  "        distance[start_node] = 0;",
		  "        que.push(std::make_pair(0, start_node));",
		  "        while(!que.empty()){",
		  "            int pos = que.top().second; que.pop();",
		  "            for(Edge e:edges[pos]){",
		  "                if(distance[e.to] > distance[pos] + e.cost){",
		  "                    distance[e.to] = distance[pos] + e.cost;",
		  "                    que.push(std::make_pair(distance[e.to], e.to));",
		  "                }",
		  "            }",
		  "        }",
		  "        return distance;",
		  "    }",
		  "    void scc_dfs_fwd(int v, std::vector<bool>& used, std::vector<int>& postorder){",
		  "        used[v] = true;",
		  "        for(Edge e:edges[v]){",
		  "            if(!used[e.to])scc_dfs_fwd(e.to, used, postorder);",
		  "        }",
		  "        //帰りがけ順",
		  "        postorder.push_back(v);",
		  "    }",
		  "    void scc_dfs_bwd(int v, int k, std::vector<bool>& used, std::vector<int>& topo_order){",
		  "        used[v] = true;",
		  "        topo_order[v] = k;",
		  "        for(Edge e: reverse_edges[v]){",
		  "            if(!used[e.to])scc_dfs_bwd(e.to, k, used, topo_order);",
		  "        }",
		  "    }",
		  "    std::vector<int> scc(){",
		  "        std::vector<bool> used(num_node, false);",
		  "        std::vector<int> postorder(num_node, 0);",
		  "        std::vector<int> topo_order(num_node, -1);",
		  "",
		  "        postorder.clear();",
		  "        //forward dfs",
		  "        for(int i=0; i<num_node; i++){",
		  "            if(!used[i]) scc_dfs_fwd(i, used, postorder);",
		  "        }",
		  "        //backward dfs",
		  "        std::fill(used.begin(), used.end(), false);",
		  "        int k=0;",
		  "        for(int i = num_node-1; i>=0; i--){",
		  "            if(!used[postorder[i]]){",
		  "                scc_dfs_bwd(postorder[i], k, used, topo_order);",
		  "                k++;",
		  "            }",
		  "        }",
		  "        return topo_order;",
		  "    }",
		  "};"
		],
		"description": "graph"
	  },
	// greatest common divider
	"gcd": {
		"prefix": "gcd",
		"body": [
		  "long long gcd(long long a, long long b){",
		  "    if(b==0) return a;",
		  "    return gcd(b, a%b);",
		  "}",
		  "int gcd(int a, int b){",
		  "    if(b==0) return a;",
		  "    return gcd(b, a%b);",
		  "}"
		],
		"description": "gcd"
	  },
	//mint, combination
	"mint": {
		"prefix": "mint",
		"body": [
		  "struct mint {",
		  "  long long x;",
		  "  mint(long long x=0):x((x%MOD+MOD)%MOD){}",
		  "  mint operator-() const { return mint(-x);}",
		  "  mint& operator+=(const mint a) {",
		  "    if ((x += a.x) >= MOD) x -= MOD;",
		  "    return *this;",
		  "  }",
		  "  mint& operator-=(const mint a) {",
		  "    if ((x += MOD-a.x) >= MOD) x -= MOD;",
		  "    return *this;",
		  "  }",
		  "  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}",
		  "  mint operator+(const mint a) const { return mint(*this) += a;}",
		  "  mint operator-(const mint a) const { return mint(*this) -= a;}",
		  "  mint operator*(const mint a) const { return mint(*this) *= a;}",
		  "  mint pow(long long t) const {",
		  "    if (!t) return 1;",
		  "    mint a = pow(t>>1);",
		  "    a *= a;",
		  "    if (t&1) a *= *this;",
		  "    return a;",
		  "  }",
		  "",
		  "  // for prime mod",
		  "  mint inv() const { return pow(MOD-2);}",
		  "  mint& operator/=(const mint a) { return *this *= a.inv();}",
		  "  mint operator/(const mint a) const { return mint(*this) /= a;}",
		  "};",
		  "std::istream& operator>>(std::istream& is, mint& a) { return is >> a.x;}",
		  "std::ostream& operator<<(std::ostream& os, const mint& a) { return os << a.x;}",
		  "struct combination {",
		  "  std::vector<mint> fact, ifact;",
		  "  combination(int n):fact(n+1),ifact(n+1) {",
		  "    assert(n < MOD);",
		  "    fact[0] = 1;",
		  "    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;",
		  "    ifact[n] = fact[n].inv();",
		  "    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;",
		  "  }",
		  "  mint operator()(int n, int k) {",
		  "    if (k < 0 || k > n) return 0;",
		  "    return fact[n]*ifact[k]*ifact[n-k];",
		  "  }",
		  "};"
		],
		"description": "mint"
	  },
	// initial template
	"init": {
		"prefix": "init",
		"body": [
		  "#include <bits/stdc++.h>",
		  "// vector input",
		  "template<typename T> std::istream& operator >> (std::istream& is, std::vector<T>& vec){",
		  "    for(T& x: vec) is >> x;",
		  "    return is;",
		  "}",
		  "// vector join",
		  "template<typename T> std::string join(std::vector<T>& vec, std::string sep = \",\"){",
		  "    std::stringstream ss;",
		  "    ss << \"{\";",
		  "    for(int i=0; i<vec.size(); i++){",
		  "        ss << vec[i] << ( i+1 == vec.size() ? \"}\" : sep );",
		  "    }",
		  "    return ss.str();",
		  "}",
		  "",
		  "// pair join",
		  "template<typename T, typename U> std::string join(std::pair<T, U>& pair_var, std::string sep = \",\") {",
		  "    std::stringstream ss;",
		  "    ss << \"(\" << pair_var.first << sep << pair_var.second << \")\";",
		  "    return ss.str();",
		  "}",
		  "// map join",
		  "template<typename T, typename U> std::string join (std::map<T, U>& map_var, std::string sep = \",\") {",
		  "    std::stringstream ss;",
		  "    ss << \"{\";",
		  "    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {",
		  "        ss << \"{\" << itr->first << \":\" << itr->second << \"}\";",
		  "        itr++;",
		  "        if(itr != map_var.end()) ss << sep;",
		  "        itr--;",
		  "    }",
		  "    ss << \"}\";",
		  "    return ss.str();",
		  "}",
		  "// set join",
		  "template<typename T> std::string join(std::set<T>& set_var, std::string sep = \",\") {",
		  "    std::stringstream ss;",
		  "    ss << \"{\";",
		  "    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {",
		  "        ss << *itr;",
		  "        ++itr;",
		  "        if(itr != set_var.end()) ss << sep;",
		  "        itr--;",
		  "    }",
		  "    ss << \"}\";",
		  "    return ss.str();",
		  "}",
		  "",
		  "//constant",
		  "const int INF = INT32_MAX/2;",
		  "const int MOD = 1e9+7;",
		  "const long long LINF = LONG_LONG_MAX/2;",
		  "",
		  "int main(){",
		  "    using namespace std;",
		  "    ",
		  "    $0",
		  "    ",
		  "    return 0;",
		  "}"
		],
		"description": "init"
	  }
}